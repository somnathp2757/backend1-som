// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
import { RetryOperationType, retry } from "@azure/core-amqp";
import { ruleManagerLogger as logger } from "./log";
import { isSqlRuleAction, } from "./serializers/ruleResourceSerializer";
import { getUniqueName } from "./util/utils";
import { throwErrorIfConnectionClosed } from "./util/errors";
import { SpanStatusCode, SpanKind } from "@azure/core-tracing";
import { createServiceBusSpan } from "./diagnostics/tracing";
/**
 * @internal
 */
export class ServiceBusRuleManagerImpl {
    /**
     * @internal
     * @throws Error if the underlying connection is closed.
     */
    constructor(_context, _entityPath, _retryOptions = {}) {
        this._context = _context;
        this._entityPath = _entityPath;
        this._retryOptions = _retryOptions;
        /**
         * Denotes if close() was called on this sender
         */
        this._isClosed = false;
        throwErrorIfConnectionClosed(_context);
        this.entityPath = _entityPath;
        this.name = getUniqueName("ruleManager");
    }
    get isClosed() {
        return this._isClosed || this._context.wasConnectionCloseCalled;
    }
    async createRule(ruleName, filter, ruleActionOrOperationOptions, options) {
        let sqlRuleAction = undefined;
        let operOptions;
        if (ruleActionOrOperationOptions) {
            if (isSqlRuleAction(ruleActionOrOperationOptions)) {
                // Overload#2 - where the sqlExpression in the ruleAction is defined
                sqlRuleAction = ruleActionOrOperationOptions;
                operOptions = options;
            }
            else {
                // Overload#1 - where the sqlExpression in the ruleAction is undefined
                operOptions = Object.assign(Object.assign({}, ruleActionOrOperationOptions), options);
            }
        }
        const { span } = createServiceBusSpan("ServiceBusRuleManager.createRule", operOptions, this.entityPath, this._context.config.host, {
            kind: SpanKind.CLIENT,
        });
        try {
            const addRuleOperationPromise = async () => {
                return this._context
                    .getManagementClient(this._entityPath)
                    .addRule(ruleName, filter, sqlRuleAction === null || sqlRuleAction === void 0 ? void 0 : sqlRuleAction.sqlExpression, Object.assign(Object.assign({}, operOptions), { associatedLinkName: this.name, requestName: "addRule", timeoutInMs: this._retryOptions.timeoutInMs }));
            };
            const config = {
                operation: addRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: operOptions === null || operOptions === void 0 ? void 0 : operOptions.abortSignal,
            };
            const result = retry(config);
            span.setStatus({ code: SpanStatusCode.OK });
            return result;
        }
        catch (error) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error.message,
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Get all rules associated with the subscription.
     */
    async getRules(options) {
        const { span } = createServiceBusSpan("ServiceBusRuleManager.getRules", options, this.entityPath, this._context.config.host, {
            kind: SpanKind.CLIENT,
        });
        try {
            const getRulesOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).getRules(Object.assign(Object.assign({}, options), { associatedLinkName: this.name, requestName: "getRules", timeoutInMs: this._retryOptions.timeoutInMs }));
            };
            const config = {
                operation: getRulesOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            };
            const result = retry(config);
            span.setStatus({ code: SpanStatusCode.OK });
            return result;
        }
        catch (error) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error.message,
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    listRulesPage(marker, options = {}) {
        var _a;
        return __asyncGenerator(this, arguments, function* listRulesPage_1() {
            do {
                const rules = yield __await(this.getRules(Object.assign({ skip: Number(marker), maxCount: (_a = options.maxPageSize) !== null && _a !== void 0 ? _a : 100 }, options)));
                if (rules.length > 0) {
                    yield yield __await(rules);
                    marker = String(Number(marker !== null && marker !== void 0 ? marker : 0) + rules.length);
                }
                else {
                    break;
                }
            } while (marker);
        });
    }
    listRulesAll(options = {}) {
        return __asyncGenerator(this, arguments, function* listRulesAll_1() {
            var e_1, _a;
            let marker;
            try {
                for (var _b = __asyncValues(this.listRulesPage(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(segment)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the rules
     * under the specified subscription.
     *
     * .byPage() returns an async iterable iterator to list the rules in pages.
     *
     * @returns An asyncIterableIterator that supports paging.
     */
    listRules(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        logger.verbose(`Performing operation - listRules() with options: %j`, options);
        const iter = this.listRulesAll(options);
        return {
            /**
             */
            next() {
                return iter.next();
            },
            /**
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             */
            byPage: (settings = {}) => {
                return this.listRulesPage(undefined, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            },
        };
    }
    /**
     * Deletes a rule.
     */
    async deleteRule(ruleName, options) {
        const { span } = createServiceBusSpan("ServiceBusRuleManager.deleteRule", options, this.entityPath, this._context.config.host, {
            kind: SpanKind.CLIENT,
        });
        try {
            const removeRuleOperationPromise = async () => {
                return this._context.getManagementClient(this._entityPath).removeRule(ruleName, Object.assign(Object.assign({}, options), { associatedLinkName: this.name, requestName: "removeRule", timeoutInMs: this._retryOptions.timeoutInMs }));
            };
            const config = {
                operation: removeRuleOperationPromise,
                connectionId: this._context.connectionId,
                operationType: RetryOperationType.management,
                retryOptions: this._retryOptions,
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
            };
            const result = retry(config);
            span.setStatus({ code: SpanStatusCode.OK });
            return result;
        }
        catch (error) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: error.message,
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
}
//# sourceMappingURL=serviceBusRuleManager.js.map